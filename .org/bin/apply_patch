#!/usr/bin/env bash
# Robust patch applier for AI-generated patches.
# Supports:
#   *** Begin Patch / *** End Patch
#   *** Update File: path
#   *** Add File: path
#   *** Delete File: path
#   *** Rename File: old -> new
#   @@ ... @@ hunks with -, +, and space context lines
# Anchor directives inside @@ header:
#   @@ at:top @@              -> insert after shebang / after import block
#   @@ at:bottom @@           -> append at end of file
#   @@ before:/regex/ @@      -> insert before first line matching regex
#   @@ after:/regex/ @@       -> insert after first line matching regex
#
# Fallbacks:
#   - If + block already exists -> success (idempotent)
#   - If only + lines and no anchor -> insert near top (after shebang/imports)
#   - Whitespace-insensitive search for - blocks
#
# Usage:
#   apply_patch [--dry-run] [--verbose] <<'PATCH'
#   *** Begin Patch
#   *** Update File: src/app.ts
#   @@ at:top @@
#   +console.log("cwd=", process.cwd());
#   *** End Patch
#   PATCH

set -euo pipefail

DRY_RUN=0
VERBOSE=0
for a in "$@"; do
  case "$a" in
    --dry-run) DRY_RUN=1 ;;
    --verbose|-v) VERBOSE=1 ;;
    *) echo "apply_patch: unknown arg: $a" >&2; exit 2 ;;
  esac
done

tmp="$(mktemp -t apply_patch.XXXXXX)"
trap 'rm -f "$tmp"' EXIT
cat >"$tmp"

if ! command -v python3 >/dev/null 2>&1; then
  echo "apply_patch: python3 is required" >&2
  exit 1
fi

python3 - "$tmp" "$DRY_RUN" "$VERBOSE" <<'PY'
import sys, os, re, shutil, time, json
patch_path = sys.argv[1]
DRY_RUN = sys.argv[2] == "1"
VERBOSE = sys.argv[3] == "1"

def dbg(*a):
    if VERBOSE:
        print("[apply_patch]", *a, file=sys.stderr)

def slurp(p):
    with open(p, "r", encoding="utf-8", errors="ignore") as f:
        return f.read()

text = slurp(patch_path)

# Extract payload between Begin/End if present
m = re.search(r'^\*\*\*\s*Begin Patch\s*$([\s\S]*?)^\*\*\*\s*End Patch\s*$', text, re.M)
payload = m.group(1) if m else text

# Strip code fences
payload = re.sub(r'```[a-zA-Z0-9_-]*\s*', '', payload)
payload = re.sub(r'```', '', payload)
payload = payload.replace('\r\n', '\n').replace('\r', '\n')

# Parse operations
ops = []
lines = payload.splitlines()
i = 0

def parse_header(kind, line):
    rest = line.split(f"{kind}:", 1)[1].strip()
    return rest

while i < len(lines):
    line = lines[i]
    if not line.startswith('*** '):
        i += 1; continue

    if 'Update File:' in line:
        path = parse_header('Update File', line)
        cur = {"op":"update", "path":path, "hunks":[]}
        i += 1
        while i < len(lines) and not lines[i].startswith('*** '):
            if lines[i].startswith('@@'):
                header = lines[i].strip()
                # parse anchor from header
                anchor = {}
                # patterns: at:top | at:bottom | before:/.../ | after:/.../
                for key in ("at:top","at:bottom"):
                    if key in header: anchor["type"]=key.split(":")[1]
                m_b = re.search(r'before:/(.*?)/', header)
                if m_b: anchor["type"]="before"; anchor["pattern"]=m_b.group(1)
                m_a = re.search(r'after:/(.*?)/', header)
                if m_a: anchor["type"]="after"; anchor["pattern"]=m_a.group(1)
                i += 1
                minus, plus = [], []
                while i < len(lines) and not lines[i].startswith('@@') and not lines[i].startswith('*** '):
                    ln = lines[i]
                    if ln.startswith('+'): plus.append(ln[1:])
                    elif ln.startswith('-'): minus.append(ln[1:])
                    elif ln.startswith(' '): minus.append(ln[1:]); plus.append(ln[1:])
                    elif ln.strip()=='':
                        minus.append(''); plus.append('')
                    else:
                        # tolerate accidental raw lines as context
                        minus.append(ln); plus.append(ln)
                    i += 1
                cur["hunks"].append({"minus":minus, "plus":plus, "anchor":anchor})
            else:
                i += 1
        ops.append(cur); continue

    if 'Add File:' in line:
        path = parse_header('Add File', line)
        i += 1
        buf=[]
        while i < len(lines) and not lines[i].startswith('*** '):
            buf.append(lines[i]); i+=1
        # strip leading '+'s if mostly present
        non_empty = [b for b in buf if b.strip()]
        if non_empty and sum(1 for b in non_empty if b.startswith('+'))/len(non_empty) > 0.6:
            buf=[b[1:] if b.startswith('+') else b for b in buf]
        content="\n".join(buf)
        ops.append({"op":"add","path":path,"content":content})
        continue

    if 'Delete File:' in line:
        path = parse_header('Delete File', line)
        ops.append({"op":"delete","path":path})
        i += 1; continue

    if 'Rename File:' in line:
        rest = parse_header('Rename File', line)
        m2 = re.match(r'(.+?)(?:\s*->\s*|\s+to\s+)(.+)$', rest)
        if m2:
            ops.append({"op":"rename","from":m2.group(1).strip(),"to":m2.group(2).strip()})
        i += 1; continue

    i += 1

if not ops:
    print("apply_patch: no operations recognized", file=sys.stderr)
    sys.exit(1)

def ensure_dir(p):
    d=os.path.dirname(p)
    if d and not os.path.exists(d):
        os.makedirs(d, exist_ok=True)

def backup(p):
    if os.path.exists(p):
        ts=time.strftime("%Y%m%d-%H%M%S")
        bak=f"{p}.bak.{ts}"
        ensure_dir(bak)
        shutil.copy2(p,bak)
        dbg("backup",bak)

def norm(s): return re.sub(r'\s+',' ',s.strip())

def find_exact(hay:list[str], needle:list[str])->int:
    n=len(needle)
    if n==0: return -1
    for j in range(0, len(hay)-n+1):
        if hay[j:j+n]==needle: return j
    return -1

def find_fuzzy(hay:list[str], needle:list[str])->int:
    n=len(needle)
    if n==0: return -1
    H=[norm(x) for x in hay]; N=[norm(x) for x in needle]
    for j in range(0, len(H)-n+1):
        if H[j:j+n]==N: return j
    return -1

def contains_block(hay:list[str], block:list[str])->bool:
    return find_exact(hay, block) != -1 or find_fuzzy(hay, block) != -1

def insert_top_strategy(lines:list[str], plus:list[str])->int:
    # after shebang if present
    idx=0
    if lines and lines[0].startswith("#!"):
        idx=1
    # after leading comment/header lines
    while idx < len(lines) and (lines[idx].strip()=="" or lines[idx].lstrip().startswith("//") or lines[idx].lstrip().startswith("/*")):
        idx+=1
    # after top import block for js/ts
    while idx < len(lines) and re.match(r'^\s*(import|export\s+\*)\b', lines[idx]):
        idx+=1
    return idx

def find_anchor_index(lines:list[str], anchor:dict)->int:
    if not anchor or "type" not in anchor: return -1
    t = anchor["type"]
    if t=="top": return insert_top_strategy(lines, [])
    if t=="bottom": return len(lines)
    if t in ("before","after"):
        pat = anchor.get("pattern","")
        try:
            rx = re.compile(pat)
        except Exception:
            return -1
        for idx, ln in enumerate(lines):
            if rx.search(ln):
                return idx if t=="before" else idx+1
    return -1

def apply_update(path:str, hunks:list[dict])->bool:
    if not os.path.exists(path):
        print(f"apply_patch: update failed, file not found: {path}", file=sys.stderr)
        return False
    with open(path,"r",encoding="utf-8",errors="ignore") as f:
        lines=f.read().splitlines()

    changed=False
    for h in hunks:
        minus=h.get("minus",[]); plus=h.get("plus",[])
        anchor=h.get("anchor",{})

        # If the + block already exists, treat as applied
        if plus and contains_block(lines, plus):
            dbg("hunk already present in",path)
            continue

        idx = -1
        # Primary: replace exact / fuzzy -block
        if minus:
            idx=find_exact(lines, minus)
            if idx==-1: idx=find_fuzzy(lines, minus)
            if idx!=-1:
                lines[idx:idx+len(minus)] = plus
                changed=True
                continue
        # No -block found (or minus empty). Try anchor directive
        aidx = find_anchor_index(lines, anchor)
        if aidx != -1:
            lines[aidx:aidx] = plus
            changed=True
            continue

        # Default fallback: if only additions, insert near top; else fail
        if minus==[] and plus:
            pos = insert_top_strategy(lines, plus)
            lines[pos:pos] = plus
            changed=True
            continue

        print(f"apply_patch: hunk not found and no valid anchor in {path}; aborting", file=sys.stderr)
        return False

    if not changed:
        dbg("no changes needed for", path)
        return True

    if DRY_RUN:
        dbg("[dry-run] would write", path)
        return True

    backup(path)
    with open(path,"w",encoding="utf-8") as f:
        f.write("\n".join(lines) + "\n")
    return True

ok=True
for op in ops:
    if op["op"]=="add":
        p=op["path"]; c=op.get("content","")
        if DRY_RUN:
            dbg("[dry-run] add", p, f"({len(c)} bytes)")
        else:
            ensure_dir(p); backup(p)
            with open(p,"w",encoding="utf-8") as f: f.write(c if c.endswith("\n") else c+"\n")
        ok = ok and True
    elif op["op"]=="update":
        ok = apply_update(op["path"], op["hunks"]) and ok
    elif op["op"]=="delete":
        p=op["path"]
        if os.path.exists(p):
            if not DRY_RUN:
                backup(p); os.remove(p)
        ok = ok and True
    elif op["op"]=="rename":
        src, dst = op["from"], op["to"]
        if not os.path.exists(src):
            print(f"apply_patch: rename failed: {src} not found", file=sys.stderr)
            ok=False
        else:
            ensure_dir(dst)
            if not DRY_RUN:
                backup(dst) if os.path.exists(dst) else None
                os.rename(src,dst)
            ok = ok and True
    else:
        print("apply_patch: unknown op", op["op"], file=sys.stderr); ok=False

sys.exit(0 if ok else 1)
PY

