#!/usr/bin/env bash
# orgctl - MIT License
# - Apple Silicon: Lima backend (Lima 1.2.x compatible)
# - Intel: minimal VBox shim (stub)

set -euo pipefail
VERSION="1.0.2"

# ---------- constants ----------
ORG_DIR="$(cd "$(dirname "$0")" && pwd)"
LIMA_NAME="${ORG_LIMA_NAME:-org.lima}"        # Lima instance name
LIMA_USER="$(whoami)"
NO_TAIL="${NO_TAIL:-false}"
ATTACH="false"                                 # attach after readiness
FAST="false"                                   # --fast => only wait for SSH (skip install wait)
VERBOSE="${ORG_VERBOSE:-0}"                    # 1 for extra chatter
WAIT_SSH_TIMEOUT="${ORG_WAIT_SSH_TIMEOUT:-360}"          # seconds to wait for SSH
WAIT_INSTALL_TIMEOUT="${ORG_WAIT_INSTALL_TIMEOUT:-1800}" # seconds to wait for org install
TAIL_PID=""

# ---------- tiny logger ----------
say(){ printf "\033[1;36m==>\033[0m %s\n" "$*"; }
note(){ printf "\033[0;90m--\033[0m %s\n" "$*"; }
warn(){ printf "\033[1;33m!!\033[0m %s\n" "$*" >&2; }
die(){  printf "\033[1;31mxx\033[0m %s\n" "$*" >&2; exit 1; }
v(){ [[ "$VERBOSE" = "1" ]] && note "$*"; }

# ---------- utils ----------
need() { command -v "$1" >/dev/null 2>&1 || die "Missing: $1"; }
backend(){
  local m s; m="$(uname -m)"; s="$(uname -s)"
  if [[ "$m" == "arm64" && "$s" == "Darwin" ]]; then
    echo lima
  elif [[ "$m" == "x86_64" ]]; then
    echo vbox
  else
    die "Unsupported: $m/$s"
  fi
}

lima_cfg() {
  local p
  for p in \
    "${ORG_LIMA_CONFIG:-}" \
    "$PWD/.org/config/org.lima.yaml" \
    "$HOME/.config/org/org.lima.yaml" \
    "$ORG_DIR/.org/config/org.lima.yaml"
  do
    [[ -n "${p:-}" && -f "$p" ]] && { echo "$p"; return; }
  done
  cat >&2 <<'EOF'
orgctl: could not find org.lima.yaml

Searched:
  $ORG_LIMA_CONFIG
  $PWD/.org/config/org.lima.yaml
  $HOME/.config/org/org.lima.yaml
  $ORG_DIR/.org/config/org.lima.yaml

Fix:
  export ORG_LIMA_CONFIG="$PWD/.org/config/org.lima.yaml"
  # or
  mkdir -p ~/.config/org && ln -s "$PWD/.org/config/org.lima.yaml" ~/.config/org/org.lima.yaml
EOF
  exit 1
}

# ---------- Lima helpers ----------
lima_exists() {
  [[ -d "$HOME/.lima/$LIMA_NAME" ]] \
    || limactl list 2>/dev/null | awk 'NR>1{print $1}' | grep -qx "$LIMA_NAME" 2>/dev/null
}

brew_prefix(){ command -v brew >/dev/null 2>&1 && brew --prefix || echo /opt/homebrew; }
brew_has_vmnet(){ command -v brew >/dev/null 2>&1 && brew list --formula 2>/dev/null | grep -qx socket_vmnet; }
vmnet_running(){
  pgrep -f '/socket_vmnet(/socket_vmnet)?' >/dev/null 2>&1 || pgrep -f 'socket_vmnet' >/dev/null 2>&1
}

ensure_vmnet_binary() {
  [[ "$(uname -s)" == "Darwin" ]] || return 0
  local hb="$(brew_prefix)/opt/socket_vmnet/bin/socket_vmnet"
  local sys="/opt/socket_vmnet/bin/socket_vmnet"
  if [[ -L "$sys" ]]; then
    say "Replacing symlink $sys with real binary copy (Lima 1.2.x requirement)"
    sudo rm "$sys"
    sudo cp "$hb" "$sys"
    sudo chmod 755 "$sys"
  elif [[ ! -x "$sys" ]]; then
    say "Installing socket_vmnet with Homebrew…"
    brew install socket_vmnet
    sudo mkdir -p /opt/socket_vmnet/bin
    sudo cp "$hb" "$sys"
    sudo chmod 755 "$sys"
  fi
}

start_vmnet(){
  ensure_vmnet_binary || true
  brew_has_vmnet || brew install socket_vmnet
  say "Starting socket_vmnet (requires sudo)…"
  sudo brew services restart socket_vmnet
}

ensure_vmnet_if_needed(){
  [[ "$(uname -s)" == "Darwin" ]] || return 0
  local cfg="$1"
  grep -qE '^[[:space:]]*networks:' "$cfg" || return 0
  vmnet_running && return 0
  if [[ -t 0 && -t 1 ]]; then
    echo
    warn "Networking helper 'socket_vmnet' is not running."
    read -r -p "Fix/install/start it now via Homebrew (sudo)? [Y/n] " ans; ans=${ans:-Y}
    [[ $ans =~ ^[Yy]$ ]] && start_vmnet || warn "Continuing without it (provisioning may stall)…"
  else
    warn "socket_vmnet not running; provisioning may stall."
  fi
}

# Spinner safe for bash-3.2
spinner_step(){ local i="$1"; local spin='|/-\'; printf "%s" "${spin:$((i%4)):1}"; }

wait_for_ssh(){
  local i=0
  note "Sleeping 5 seconds"
  sleep 5
  printf "Waiting for VM SSH to be ready "
  while (( i < WAIT_SSH_TIMEOUT )); do
    if limactl shell "$LIMA_NAME" -- true >/dev/null 2>&1; then
      printf "\nSSH is ready.\n"
      return 0
    fi
    printf "\rWaiting for VM SSH to be ready %s" "$(spinner_step "$i")"
    ((i++))
    sleep 2
  done
  printf "\n"
  die "Timed out waiting for SSH. See: tail -f ~/.lima/$LIMA_NAME/serial*.log"
}

# First create: NON-interactive & synchronous (no YAML editor).
# If limactl returns non-zero (e.g., “did not receive an event with the 'running' status”),
# treat it as transient and proceed to our own SSH/provision wait.
# Subsequent starts: non-blocking (we still wait for SSH ourselves).
lima_start() {
  local cfg="$1"
  if lima_exists; then
    say "Starting existing Lima instance (non-blocking)…"
    nohup limactl start "$LIMA_NAME" >/tmp/orgctl-lima-start.log 2>&1 < /dev/null &
  else
    say "Creating Lima instance from $cfg (first run; --tty=false, synchronous)…"
    set +e
    yes | limactl start --name "$LIMA_NAME" --tty=false "$cfg"
    local rc=$?
    set -e
    if (( rc != 0 )); then
      warn "limactl start exited with $rc; continuing to wait for SSH (startup often continues successfully)."
    fi
  fi
}

tail_vm_log() {
  local log
  log="$(ls -1t "$HOME/.lima/$LIMA_NAME"/serial*.log 2>/dev/null | head -n1 || true)"
  [[ -n "$log" ]] || return 0
  say "Tailing VM console log ($log)…"
  tail -f "$log" &
  TAIL_PID=$!
  trap 'kill "$TAIL_PID" 2>/dev/null || true' EXIT INT TERM
}

# Map host path → guest path (~/… -> /home/<user>.linux/…)
guest_path_from_host() {
  local host_path="$1"
  local host_home="$HOME"
  local guest_home="/home/${LIMA_USER}.linux"
  if [[ "$host_path" == "$host_home"* ]]; then
    echo "${host_path/$host_home/$guest_home}"
  else
    echo "$guest_home/dev"
  fi
}

lima_attach() {
  local guest_pwd; guest_pwd="$(guest_path_from_host "$PWD")"
  say "Attaching to VM…"
  limactl shell "$LIMA_NAME" -- bash -ilc "cd \"$guest_pwd\" 2>/dev/null || cd \"\$HOME/dev/org\" 2>/dev/null || cd ~; exec bash -i -l"
}

print_host_banner_ready() {
  local cfg="$1"
  local guest_pwd; guest_pwd="$(guest_path_from_host "$PWD")"
  cat <<EOF

┌────────────── org VM (ready) ──────────────────────────────────
│ Config:    $cfg
│ Connect:   limactl shell $LIMA_NAME
│ Project:   cd "$guest_pwd"   # or: cd ~/dev/org
│ Run org:   org --ui console
└────────────────────────────────────────────────────────────────
EOF
}

print_host_banner_waiting() {
  local cfg="$1"
  cat <<EOF

┌───────────── org VM (provisioning) ────────────────────────────
│ First boot may take a while (Bun, apt, image build).
│ I will keep you posted below; dots mean “still working”.
│ You can watch logs with: tail -f ~/.lima/$LIMA_NAME/serial*.log
│ Config: $cfg
└────────────────────────────────────────────────────────────────
EOF
}

# Probe provisioning state inside the VM; prints "sudo=y bun=y org=n img=n cloud=done ufw=on"
probe_vm_state() {
  limactl shell "$LIMA_NAME" -- bash -lc '
    set +e
    s=$(command -v sudo >/dev/null && echo y || echo n)
    b=$(command -v bun  >/dev/null && echo y || echo n)
    o=$(command -v org  >/dev/null && echo y || echo n)
    if command -v podman >/dev/null 2>&1; then
      podman image exists org:debian12 >/dev/null 2>&1 && i=y || i=n
    else
      i=n
    fi
    if command -v cloud-init >/dev/null 2>&1; then
      cloud-init status 2>/dev/null | grep -q "done" && c=done || c=running
    else
      c=na
    fi
    if command -v ufw >/dev/null 2>&1; then
      ufw status 2>/dev/null | grep -q "Status: active" && u=on || u=off
    else
      u=na
    fi
    echo "sudo=$s bun=$b org=$o img=$i cloud=$c ufw=$u"
  ' 2>/dev/null || true
}

# Wait for org to be installed, printing status + filler dots
wait_for_install() {
  local cfg="$1"
  local elapsed=0; local last=""; local state=""
  print_host_banner_waiting "$cfg"
  echo "Waiting for provisioning checkpoints (sudo,bun,org,img,cloud,ufw) …"
  while (( elapsed < WAIT_INSTALL_TIMEOUT )); do
    state="$(probe_vm_state)"
    if [[ -z "$state" ]]; then
      printf "."
    else
      if [[ "$state" != "$last" ]]; then
        printf "\n[provision] %s  (t+%ss)\n" "$state" "$elapsed"
        last="$state"
      else
        printf "."
      fi
      if [[ "$state" == *"org=y"* ]]; then
        printf "\nProvisioning checkpoint reached: org installed.\n"
        return 0
      fi
    fi
    sleep 5
    elapsed=$((elapsed+5))
  done
  echo
  die "Timeout waiting for provisioning. Check ~/.lima/$LIMA_NAME/serial*.log"
}

# ---------- Podman-first (quick try, no VM) ----------
podman_machine_name(){ echo "${ORG_PODMAN_MACHINE:-podman-machine-default}"; }
podman_machine_exists(){ podman machine inspect "$(podman_machine_name)" >/dev/null 2>&1; }
ensure_podman(){
  if ! command -v podman >/dev/null 2>&1; then
    if command -v brew >/dev/null 2>&1; then
      say "Installing Podman via Homebrew…"
      brew install podman
    else
      die "Podman not found and Homebrew missing. Please install Podman first."
    fi
  fi
  if ! podman_machine_exists; then
    say "Initializing Podman machine…"
    podman machine init
  fi
  say "Starting Podman machine…"
  podman machine start
  v "Podman info:"; v "$(podman info 2>/dev/null | sed -n '1,40p')"
}
podman_build_image(){
  local tag="${ORG_IMAGE_TAG:-org:debian12}"
  if [[ -f "Containerfile" ]]; then
    say "Building container image (tag=$tag)…"
    podman build --pull=always -t "$tag" -f Containerfile .
  else
    warn "Containerfile not found in $(pwd); skipping image build."
  fi
  say "Podman-ready. You can run:  org --ui tmux   (will run inside the container)."
}

# ---------- commands ----------
cmd_quickstart() {
  # parse flags
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --no-tail)  NO_TAIL=true; shift;;
      --attach)   ATTACH=true; shift;;
      --fast)     FAST=true; shift;;
      --verbose|-v) VERBOSE=1; shift;;
      *) die "Unknown option: $1";;
    esac
  done

  if [[ "$(backend)" != "lima" ]]; then
    die "quickstart is for Apple Silicon (Lima)."
  fi
  need limactl
  local cfg; cfg="$(lima_cfg)"
  ensure_vmnet_if_needed "$cfg"
  say "Using Lima config: $cfg"
  lima_start "$cfg"

  wait_for_ssh
  [[ "$NO_TAIL" != "true" ]] && tail_vm_log
  [[ "$FAST" != "true" ]] && wait_for_install "$cfg"
  print_host_banner_ready "$cfg"

  if [[ "$ATTACH" == "true" ]]; then
    lima_attach
  else
    note "(Not attaching automatically. Use:  limactl shell $LIMA_NAME)"
  fi
}

cmd_vm(){
  local sub="${1:-}"; shift || true
  case "$(backend)" in
    lima)
      case "$sub" in
        init|up)
          need limactl
          ensure_vmnet_if_needed "$(lima_cfg)"
          lima_start "$(lima_cfg)"
          wait_for_ssh
          print_host_banner_ready "$(lima_cfg)"
          ;;
        stop)     need limactl; limactl stop "$LIMA_NAME" || true;;
        destroy)  need limactl; limactl delete "$LIMA_NAME" || true;;
        ssh)      need limactl; lima_attach;;
        logs)     tail_vm_log;;
        *) die "Unknown vm subcommand: $sub";;
      esac
      ;;
    vbox)
      case "$sub" in
        init) echo "TODO: VBox unattended install";;
        *) echo "Use VBox directly for now";;
      esac
      ;;
  esac
}

cmd_podman(){
  local sub="${1:-}"; shift || true
  case "$sub" in
    first)
      ensure_podman
      podman_build_image
      ;;
    start)
      ensure_podman
      ;;
    build)
      ensure_podman
      podman_build_image
      ;;
    *) cat <<EOF
Usage:
  orgctl podman first     # install/start Podman + build image (no VM)
  orgctl podman start     # just ensure Podman machine is up
  orgctl podman build     # (re)build Containerfile as org:debian12
EOF
      ;;
  esac
}

usage(){ cat <<EOF
orgctl v$VERSION
USAGE:
  orgctl quickstart [--no-tail] [--attach] [--fast] [--verbose|-v]
  orgctl vm <init|up|stop|destroy|ssh|logs>
  orgctl podman <first|start|build>
  orgctl version
ENV:
  ORG_LIMA_CONFIG                 path to org.lima.yaml (optional)
  ORG_LIMA_NAME                   Lima instance name (default: $LIMA_NAME)
  NO_TAIL=true                    disable serial log tail in quickstart
  ORG_WAIT_SSH_TIMEOUT=SEC        SSH wait timeout (default: $WAIT_SSH_TIMEOUT)
  ORG_WAIT_INSTALL_TIMEOUT=SEC    org install wait timeout (default: $WAIT_INSTALL_TIMEOUT)
  ORG_VERBOSE=1                   verbose mode (more truthful chatter)
NOTES:
  • First VM create runs limactl with --tty=false (no interactive YAML editor).
  • If limactl returns a transient error, we still proceed to SSH/provision wait.
  • Default quickstart waits for SSH and for 'org' to be installed in the VM.
  • Use --fast to skip the install wait (not recommended on first boot).
  • Prefer a faster tryout?  Run:  orgctl podman first
EOF
}

case "${1:-}" in
  quickstart) shift; cmd_quickstart "$@";;
  vm)         shift; cmd_vm "$@";;
  podman)     shift; cmd_podman "$@";;
  version)    echo "$VERSION";;
  ""|help|-h|--help) usage;;
  *) usage; exit 1;;
esac
