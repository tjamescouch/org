#!/usr/bin/env bash
# orgctl - MIT License
# Unified orchestration CLI for org
# - Apple Silicon (arm64): Lima backend with .org/config/org.lima.yaml
# - Intel (x86_64): VirtualBox backend
# Works with Lima 1.2.1 (no --detach / --user flags)

set -euo pipefail
VERSION="0.6.0"

ORG_DIR="$(cd "$(dirname "$0")" && pwd)"
LIMA_CONFIG="$ORG_DIR/.org/config/org.lima.yaml"
VM_NAME="org-vm"
HOST_SSH_PORT="${HOST_SSH_PORT:-2222}"
SSH_USER="$(whoami)"   # default to host username (works in Lima 1.2.1)

backend() {
  arch="$(uname -m)"
  sys="$(uname -s)"
  if [[ "$arch" == "arm64" && "$sys" == "Darwin" ]]; then
    echo "lima"
  elif [[ "$arch" == "x86_64" ]]; then
    echo "vbox"
  else
    echo "Unsupported arch: $arch ($sys)" >&2
    exit 1
  fi
}

ssh_base() {
  echo "-p" "$HOST_SSH_PORT" "-o" "StrictHostKeyChecking=no" "-o" "UserKnownHostsFile=/dev/null"
}

# ---------- Lima backend ----------
lima_vm_init() {
  [[ -f "$LIMA_CONFIG" ]] || { echo "Missing $LIMA_CONFIG"; exit 1; }
  # Lima 1.2.1 has no --detach, so this will stream logs until boot completes.
  echo "Starting Lima VM with config $LIMA_CONFIG ..."
  limactl start --name org.lima "$LIMA_CONFIG"
}
lima_vm_up() { limactl start --name org.lima || true; }
lima_vm_stop() { limactl stop org.lima || true; }
lima_vm_destroy() { limactl delete org.lima || true; }
lima_vm_ssh() { limactl shell org.lima; }
lima_vm_export() { echo "Export not supported for Lima"; }

# ---------- VirtualBox backend ----------
need() { command -v "$1" >/dev/null 2>&1 || { echo "Missing dependency: $1" >&2; exit 1; }; }
assert_virtualbox() { need VBoxManage; }

vbox_vm_init() {
  assert_virtualbox
  if VBoxManage list vms | grep -q "\"$VM_NAME\""; then
    echo "VM already exists: $VM_NAME"; exit 1
  fi
  echo "TODO: implement full VBox unattended install"
}
vbox_vm_up() { VBoxManage startvm "$VM_NAME" --type headless; }
vbox_vm_stop() { VBoxManage controlvm "$VM_NAME" acpipowerbutton || true; }
vbox_vm_destroy() { VBoxManage unregistervm "$VM_NAME" --delete || true; }
vbox_vm_ssh() { ssh "$(ssh_base[@])" "${SSH_USER}@127.0.0.1"; }
vbox_vm_export() { VBoxManage export "$VM_NAME" --output "$VM_NAME.ova"; }

# ---------- App install ----------
looks_like_org_repo() {
  [[ -f "package.json" || -f "bun.toml" ]] && [[ -d "src" || -f "install.sh" ]]
}

host_sync_into_vm() {
  need rsync
  local tmp_excl; tmp_excl="$(mktemp)"
  cat > "$tmp_excl" <<EOF
.git/
node_modules/
dist/
build/
.cache/
.DS_Store
EOF
  echo "Syncing current directory to ~/org ..."
  rsync -az --delete --progress \
    --exclude-from="$tmp_excl" \
    -e "ssh $(ssh_base | xargs echo)" \
    ./ "${SSH_USER}@127.0.0.1:/home/${SSH_USER}/org/"
  rm -f "$tmp_excl"
}

run_install_script() {
  echo "Running install.sh inside VM ..."
  ssh "$(ssh_base[@])" "${SSH_USER}@127.0.0.1" \
    "bash -lc 'chmod +x /home/${SSH_USER}/org/install.sh || true; /home/${SSH_USER}/org/install.sh'"
}

git_clone_in_vm() {
  local url="$1"
  ssh "$(ssh_base[@])" "${SSH_USER}@127.0.0.1" \
    "bash -lc 'rm -rf /home/${SSH_USER}/org && git clone ${url} /home/${SSH_USER}/org'"
}

tarball_install_in_vm() {
  local url="$1" sha="$2"
  local verify=""
  [[ -n "$sha" ]] && verify="echo '${sha}  /tmp/org.tgz' | sha256sum -c - &&"
  ssh "$(ssh_base[@])" "${SSH_USER}@127.0.0.1" \
    "bash -lc 'rm -rf /home/${SSH_USER}/org && mkdir -p /home/${SSH_USER}/org && \
      curl -fsSL ${url@Q} -o /tmp/org.tgz && ${verify} \
      tar -xzf /tmp/org.tgz -C /home/${SSH_USER}/org --strip-components=1'"
}

cmd_app_install() {
  FROM="host"
  REPO_URL="https://github.com/tjamescouch/org.git"
  TAR_URL=""; TAR_SHA=""
  NO_RUN="no"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --from) FROM="$2"; shift 2 ;;
      --repo) REPO_URL="$2"; shift 2 ;;
      --tar-url) TAR_URL="$2"; shift 2 ;;
      --tar-sha256) TAR_SHA="$2"; shift 2 ;;
      --no-run) NO_RUN="yes"; shift ;;
      *) echo "Unknown option: $1"; exit 1 ;;
    esac
  done

  case "$FROM" in
    host) looks_like_org_repo && host_sync_into_vm || git_clone_in_vm "$REPO_URL" ;;
    git) git_clone_in_vm "$REPO_URL" ;;
    tar) tarball_install_in_vm "$TAR_URL" "$TAR_SHA" ;;
  esac

  [[ "$NO_RUN" == "yes" ]] || run_install_script
}

# ---------- Dispatcher ----------
cmd_vm() {
  sub="${1:-}"; shift || true
  case "$(backend)" in
    lima)
      case "$sub" in
        init) lima_vm_init ;;
        up) lima_vm_up ;;
        stop) lima_vm_stop ;;
        destroy) lima_vm_destroy ;;
        ssh) lima_vm_ssh ;;
        export) lima_vm_export ;;
        *) echo "Unknown vm subcommand: $sub"; exit 1 ;;
      esac
      ;;
    vbox)
      case "$sub" in
        init) vbox_vm_init ;;
        up) vbox_vm_up ;;
        stop) vbox_vm_stop ;;
        destroy) vbox_vm_destroy ;;
        ssh) vbox_vm_ssh ;;
        export) vbox_vm_export ;;
        *) echo "Unknown vm subcommand: $sub"; exit 1 ;;
      esac
      ;;
  esac
}

usage() {
  cat <<EOF
orgctl v$VERSION

USAGE:
  orgctl vm <init|up|stop|destroy|ssh|export>
  orgctl app install [--from host|git|tar]
  orgctl version
EOF
}

# ---------- Main ----------
case "${1:-}" in
  vm) shift; cmd_vm "$@" ;;
  app) shift; sub="${1:-}"; shift || true
       case "$sub" in
         install) cmd_app_install "$@" ;;
         *) usage; exit 1 ;;
       esac ;;
  version) echo "$VERSION" ;;
  ""|help|-h|--help) usage ;;
  *) usage; exit 1 ;;
esac
