#!/usr/bin/env bash
# CWD-agnostic org launcher.
# - Agents work in /work (host path configurable via ORG_WORK_DIR).
# - App code mounts at /application.
# - NEW: ORG_REVIEW_MODE env + --review <yes|no> CLI (live vs review-gated).

set -Eeuo pipefail

# ---------- resolve real path to this script (portable) ----------
resolve_realpath() {
  if command -v readlink >/dev/null 2>&1; then
    readlink -f "$1" 2>/dev/null || python3 - "$1" <<'PY'
import os, sys; print(os.path.realpath(sys.argv[1]))
PY
  else
    python3 - "$1" <<'PY'
import os, sys; print(os.path.realpath(sys.argv[1]))
PY
  fi
}

SCRIPT_PATH="$(resolve_realpath "$0")"
REPO_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"

# ---------- engine/image/file ----------
ENGINE="${ORG_ENGINE:-podman}"   # set ORG_ENGINE=docker if you prefer
IMAGE="${ORG_IMAGE:-localhost/org-build:debian-12}"
FILE="${ORG_CONTAINERFILE:-$REPO_DIR/Containerfile}"


# ---------- ensure image exists (build if missing) ----------
if ! "$ENGINE" image inspect "$IMAGE" >/dev/null 2>&1; then
  echo "[org] building image with $ENGINE (this can take a while)..."
  "$ENGINE" build -t "$IMAGE" -f "$FILE" "$REPO_DIR"
  echo "[org] image built: $IMAGE"
fi

# ---------- parse CLI (NEW: --review <yes|no>) ----------
REVIEW_MODE="${ORG_REVIEW_MODE:-review}"   # default preserves current behavior
ARGS=()
while [[ $# -gt 0 ]]; do
  case "$1" in
    --review)
      shift
      val="${1:-}"
      [[ -z "$val" ]] && { echo "org: --review requires a value (yes|no)" >&2; exit 2; }
      ;;
    --review=*)
      val="${1#*=}"
      ;;
    --) ARGS+=("$@"); break;;
    *)  ARGS+=("$1"); shift; continue;;
  esac
  # normalize & map
  lc="$(printf '%s' "$val" | tr '[:upper:]' '[:lower:]')"
  case "$lc" in
    # gated/review mode
    yes|y|true|on|review|0)  REVIEW_MODE="review" ;;
    # live/pass-through (old behavior)
    no|n|false|off|live|apply|1) REVIEW_MODE="live" ;;
    *)
      echo "org: invalid --review value: $val (use yes|no|1|0|live|review)" >&2
      exit 2
      ;;
  esac
  shift
done

# REVIEW_MODE may be "live" or "review" (default live)
mode="$(printf '%s' "${REVIEW_MODE:-live}" | tr '[:upper:]' '[:lower:]')"

if [[ -n "${ORG_WORK_DIR:-}" ]]; then
  WORK_SCRATCH="$ORG_WORK_DIR"
elif [[ "$mode" == "review" ]]; then
  WORK_SCRATCH="$PWD/.org/work"
else
  WORK_SCRATCH="$PWD"
fi

mkdir -p "$WORK_SCRATCH"

echo "[org] review      = $REVIEW_MODE"
echo "[org] engine      = $ENGINE"
echo "[org] image       = $IMAGE"
echo "[org] file        = $FILE"
echo "[org] repo        = $REPO_DIR"
echo "[org] work        = $WORK_SCRATCH -> /work (rw)"
echo "[org] project(ro) = $PWD          -> /project (ro)"

# ---------- env forward (allow-list) ----------
# Build an array of ["-e","KEY=VAL", ...] so we don't rely on word-splitting.
env_allow() {
  local k v
  while IFS='=' read -r k v; do
    case "$k" in
      ORG_*|OPENAI_*|ANTHROPIC_*|OLLAMA_*|LMSTUDIO_*|AZURE_*|GOOGLE_*|GROQ_*|GEMINI_*|HTTP_PROXY|HTTPS_PROXY|ALL_PROXY|NO_PROXY|http_proxy|https_proxy|all_proxy|no_proxy|LANG|LC_*|TZ|TERM|FORCE_COLOR|NO_COLOR)
        ENV_ARR+=("-e" "${k}=${v}")
        ;;
    esac
  done < <(env)
}

ENV_ARR=(
  "-e" "ORG_PROJECT_DIR=/work"
  "-e" "ORG_APP_ENTRY=/application/src/app.ts"
  "-e" "ORG_REVIEW_MODE=${REVIEW_MODE}"   # NEW
  "-e" "TERM=${TERM:-xterm-256color}"
  "-e" "ORG_SANDBOX_BACKEND=none"
)
env_allow

# ---------- run bun inside the container, mounting the repo root ----------
# shellcheck disable=SC2086
"$ENGINE" run --rm -it \
  -v "$WORK_SCRATCH:/work:Z" \
  -v "$PWD:/project:Z,ro" \
  -v "$REPO_DIR:/application:Z" \
  -w /work \
  "${ENV_ARR[@]}" \
  "$IMAGE" bash -lc '
    set -Eeuo pipefail
    if [ "${ORG_REVIEW_MODE:-live}" = review ]; then
      # one-liner stage: copy project → work, keep /work/.org, drop .git
      rsync -a --delete --exclude ".git" --exclude ".org" /project/ /work/
    fi
    exec org "$@"
  ' org "${ARGS[@]}"
status=$?

# ---- Host-side patch review (opt-in or review mode) ----
if [[ "${ORG_HOST_REVIEW:-}" == "1" || "$(printf '%s' "$REVIEW_MODE" | tr '[:upper:]' '[:lower:]')" == "review" ]]; then
  PATCH_ROOT="$WORK_SCRATCH/.org"   # <— this mirrors /work/.org inside the container
  PATCH_HOST_PATH=""

  # legacy single-file path (if present)
  if [[ -f "$PATCH_ROOT/last-session.patch" ]]; then
    PATCH_HOST_PATH="$PATCH_ROOT/last-session.patch"
  else
    # canonical: newest .org/runs/*/session.patch
    PATCH_HOST_PATH="$(ls -t "$PATCH_ROOT"/runs/*/session.patch 2>/dev/null | head -n1 || true)"
  fi

  if [[ -n "$PATCH_HOST_PATH" && -f "$PATCH_HOST_PATH" ]]; then
    "$REPO_DIR/scripts/host-patch-review.sh" \
      --patch "$PATCH_HOST_PATH" \
      --project "$WORK_SCRATCH" || true
  else
    echo "[org] (host-review) no patch found under $PATCH_ROOT"
  fi
fi

exit "$status"