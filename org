#!/usr/bin/env bash
# CWD-agnostic org launcher.
# - Agents work in /work (host path configurable via ORG_WORK_DIR).
# - App code mounts at /application.
# - --review <yes|no> and ORG_REVIEW_MODE control live vs review-gated mode.

set -Eeuo pipefail

# ---------- resolve real path to this script (portable) ----------
resolve_realpath() {
  if command -v readlink >/dev/null 2>&1; then
    readlink -f "$1" 2>/dev/null || python3 - "$1" <<'PY'
import os, sys; print(os.path.realpath(sys.argv[1]))
PY
  else
    python3 - "$1" <<'PY'
import os, sys; print(os.path.realpath(sys.argv[1]))
PY
  fi
}

SCRIPT_PATH="$(resolve_realpath "$0")"
REPO_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"

# ---------- engine/image/file ----------
ENGINE="${ORG_ENGINE:-podman}"                # set ORG_ENGINE=docker if preferred
IMAGE="${ORG_IMAGE:-localhost/org-build:debian-12}"
FILE="${ORG_CONTAINERFILE:-$REPO_DIR/Containerfile}"

# ---------- ensure image exists (build if missing) ----------
if ! "$ENGINE" image inspect "$IMAGE" >/dev/null 2>&1; then
  echo "[org] building image with $ENGINE (this can take a while)..."
  "$ENGINE" build -t "$IMAGE" -f "$FILE" "$REPO_DIR"
  echo "[org] image built: $IMAGE"
fi

# ---------- parse CLI (NEW: --review <yes|no>) ----------
REVIEW_MODE="${ORG_REVIEW_MODE:-review}"      # keep your current default
ARGS=()
while [[ $# -gt 0 ]]; do
  case "$1" in
    --review)   shift; val="${1:-}"; [[ -z "$val" ]] && { echo "org: --review requires a value (yes|no)" >&2; exit 2; } ;;
    --review=*) val="${1#*=}" ;;
    --) ARGS+=("$@"); break;;
    *)  ARGS+=("$1"); shift; continue;;
  esac
  lc="$(printf '%s' "$val" | tr '[:upper:]' '[:lower:]')"
  case "$lc" in
    yes|y|true|on|review|0)      REVIEW_MODE="review" ;;   # gated
    no|n|false|off|live|apply|1) REVIEW_MODE="live"   ;;   # write-through
    *) echo "org: invalid --review value: $val (use yes|no|1|0|live|review)" >&2; exit 2 ;;
  esac
  shift
done

# ---------- choose /work host path (ORG_WORK_DIR overrides) ----------
mode="$(printf '%s' "${REVIEW_MODE:-live}" | tr '[:upper:]' '[:lower:]')"
if [[ -n "${ORG_WORK_DIR:-}" ]]; then
  WORK_SCRATCH="$ORG_WORK_DIR"
elif [[ "$mode" == "review" ]]; then
  WORK_SCRATCH="$PWD/.org/work"
else
  WORK_SCRATCH="$PWD"
fi
mkdir -p "$WORK_SCRATCH"

# ---- upfront repo cleanliness check ----
if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
  if [[ -n "$(git status --porcelain)" ]]; then
    echo "[org] repo is dirty. Please fix before running review mode."
    echo
    echo "To save your current work:"
    echo "    git add -A"
    echo "    git commit -m 'WIP: save dirty state before org run'"
    echo
    echo "Or to throw away changes:"
    echo "    git restore --staged ."
    echo "    git restore ."
    exit 1
  fi
else
  echo "[org] This directory is not a Git repo."
  echo "To initialize one and capture your current files:"
  echo "    git init"
  echo "    git add ."
  echo "    git commit -m 'Initial commit'"
  exit 1
fi

echo "[org] review      = $REVIEW_MODE"
echo "[org] engine      = $ENGINE"
echo "[org] image       = $IMAGE"
echo "[org] file        = $FILE"
echo "[org] repo        = $REPO_DIR"
echo "[org] work        = $WORK_SCRATCH -> /work (rw)"
echo "[org] project(ro) = $PWD          -> /project (ro)"
echo "[org] app         = $REPO_DIR     -> /application"

# ---------- env forward (allow-list) ----------
env_allow() {
  local k v
  while IFS='=' read -r k v; do
    case "$k" in
      ORG_*|OPENAI_*|ANTHROPIC_*|OLLAMA_*|LMSTUDIO_*|AZURE_*|GOOGLE_*|GROQ_*|GEMINI_*|HTTP_PROXY|HTTPS_PROXY|ALL_PROXY|NO_PROXY|http_proxy|https_proxy|all_proxy|no_proxy|LANG|LC_*|TZ|TERM|FORCE_COLOR|NO_COLOR)
        ENV_ARR+=("-e" "${k}=${v}")
        ;;
    esac
  done < <(env)
}

ENV_ARR=(
  "-e" "ORG_PROJECT_DIR=/work"
  "-e" "ORG_APP_ENTRY=/application/src/app.ts"   # image wrappers honor this
  "-e" "ORG_REVIEW_MODE=${REVIEW_MODE}"
  "-e" "TERM=${TERM:-xterm-256color}"
  "-e" "ORG_SANDBOX_BACKEND=none"
)
env_allow

# ---------- run inside the container (foreground) ----------
set +e
"$ENGINE" run --rm -it \
  -v "$WORK_SCRATCH:/work:Z" \
  -v "$PWD:/project:Z,ro" \
  -v "$REPO_DIR:/application:Z" \
  -w /work \
  "${ENV_ARR[@]}" \
  "$IMAGE" bash -lc '
    set -Eeuo pipefail
    mkdir -p /work/.org
    if [ "${ORG_REVIEW_MODE:-live}" = review ]; then
      rsync -a --delete --exclude ".git" --exclude ".org" /project/ /work/
      rm -rf /work/.git 2>/dev/null || true
      printf "gitdir: /project/.git\n" > /work/.git
      git config --global --add safe.directory /project >/dev/null 2>&1 || true
      git config --global --add safe.directory /work    >/dev/null 2>&1 || true
    fi
    exec org "$@"
  ' org "${ARGS[@]}"
status=$?
set -e

# Ctrl+C from the foreground container exits with 130
got_int=0
if [[ "$status" -eq 130 ]]; then
  got_int=1
fi

# ---------- Host-side patch review (review mode only) ----------
if [[ "$mode" == "review" ]]; then
  PATCH_ROOT="$WORK_SCRATCH/.org"   # mirror of /work/.org
  PATCH_HOST_PATH="$(ls -t "$PATCH_ROOT"/runs/*/session.patch 2>/dev/null | head -n1 || true)"
  if [[ -n "$PATCH_HOST_PATH" && -f "$PATCH_HOST_PATH" ]]; then
    if [[ ! -s "$PATCH_HOST_PATH" ]]; then
      echo "[org] (host-review) patch is empty; skipping review."
    elif [[ "$got_int" == "1" ]]; then
      echo "[org] (host-review) patch written: $PATCH_HOST_PATH"
      echo "[org] (host-review) Ctrl+C received; skipping pager."
    else
      "$REPO_DIR/scripts/host-patch-review.sh" \
        --patch   "$PATCH_HOST_PATH" \
        --project "$PWD" || true
    fi
  else
    echo "[org] (host-review) no patch found under $PATCH_ROOT"
  fi
fi

exit "$status"