#!/usr/bin/env bash
# org launcher (macOS/Linux, Bash 3.2+)
# Exit codes: 66 = not found; 127 = runtime missing
set -o pipefail

DBG="${ORG_DEBUG:-${DEBUG:-0}}"
log() { [ "$DBG" = "1" ] || return 0; printf '[org.sh] %s\n' "$*" >&2; }

# Re-entry guard
: "${ORG_LAUNCHER_ONCE:=0}"
[ "$ORG_LAUNCHER_ONCE" != "0" ] && log "re-entry blocked"
export ORG_LAUNCHER_ONCE=1

# Resolve script path (follow symlinks)
SCRIPT="${BASH_SOURCE[0]:-$0}"
while [ -L "$SCRIPT" ]; do
  L="$(readlink "$SCRIPT")"
  case "$L" in
    /*) SCRIPT="$L" ;;
    *)  SCRIPT="$(cd "$(dirname "$SCRIPT")" && cd "$(dirname "$L")" && pwd)/$(basename "$L")" ;;
  esac
done
APPDIR="$(cd "$(dirname "$SCRIPT")" && pwd)"
log "script=$SCRIPT"; log "appdir=$APPDIR"

# Parse -C/--cwd and collect remaining args
CWD=""; args=()
while [ $# -gt 0 ]; do
  case "$1" in
    -C|--cwd) shift; CWD="${1:-}"; shift || true ;;
    *) args+=("$1"); shift ;;
  esac
done

if [ -n "$CWD" ]; then
  log "cd -> $CWD"
  cd "$CWD" 2>/dev/null || { echo "org: cwd not found: $CWD" >&2; exit 66; }
fi

# Useful env for the app
export ORG_CALLER_CWD="${ORG_CALLER_CWD:-$PWD}"
export ORG_APPDIR="$APPDIR"
export ORG_SESSION_DIR="${ORG_SESSION_DIR:-$PWD/.org}"

# Resolve entrypoint (prefer src/app.ts so the UI router runs)
ENTRY="${ORG_ENTRY:-}"
if [ -z "$ENTRY" ]; then
  for p in \
    "$APPDIR/src/app.ts" \
    "$APPDIR/runner.ts" "$APPDIR/runner.mts" "$APPDIR/runner.js" \
    "$APPDIR/dist/runner.js"
  do
    [ -f "$p" ] && { ENTRY="$p"; break; }
  done
fi
# package.json bin fallback
if [ -z "$ENTRY" ] && command -v jq >/dev/null 2>&1 && [ -f "$APPDIR/package.json" ]; then
  BIN="$(jq -r 'if .bin then if (.bin|type)=="object" then (.bin.org // .bin["org"] // empty) else .bin end else empty end' "$APPDIR/package.json" 2>/dev/null || true)"
  [ -n "$BIN" ] && { case "$BIN" in /*) ENTRY="$BIN" ;; *) ENTRY="$APPDIR/$BIN" ;; esac; }
fi
[ -n "$ENTRY" ] || { echo "org: entrypoint not found. Tried src/app.ts, runner.ts/mts/js, dist/runner.js next to $APPDIR" >&2; exit 66; }

export ORG_ENTRY="$ENTRY"
log "entry=$ENTRY"
[ "$DBG" = "1" ] && { ls -l "$ENTRY" >&2 || true; head -n1 "$ENTRY" >&2 || true; }

# Default UI to console unless caller provided --ui
has_ui=0
for a in "${args[@]}"; do
  if [ "$a" = "--ui" ]; then has_ui=1; break; fi
done
if [ $has_ui -eq 0 ]; then
  args+=(--ui console)
  log "ui defaulted to console (add --ui tmux to use tmux)"
fi

# Locate Bun (prefer), else Node+tsx
pick_bun() {
  if [ -n "${BUN_BIN:-}" ] && [ -x "$BUN_BIN" ]; then echo "$BUN_BIN"; return 0; fi
  if command -v bun >/dev/null 2>&1; then command -v bun; return 0; fi
  if [ -x /root/.bun/bin/bun ]; then echo /root/.bun/bin/bun; return 0; fi
  if [ -n "${HOME:-}" ] && [ -x "$HOME/.bun/bin/bun" ]; then echo "$HOME/.bun/bin/bun"; return 0; fi
  return 1
}

if BUN="$(pick_bun)"; then
  log "exec: $BUN \"$ENTRY\" ${args[*]}"
  exec "$BUN" "$ENTRY" "${args[@]}"
fi

if command -v node >/dev/null 2>&1; then
  if command -v npx >/dev/null 2>&1; then
    log "exec: npx --yes tsx \"$ENTRY\" ${args[*]}"
    exec npx --yes tsx "$ENTRY" "${args[@]}"
  fi
  echo "org: Node found but tsx is missing. Install tsx (npm i -g tsx) or install Bun." >&2
  exit 127
fi

echo "org: neither Bun nor Node runtime found in PATH." >&2
exit 127
